# Operating System Protection Mechanisms

Modern OSs provide protection:

- among the users, like a legitimate user vs intruder/malware
- of the OS itself, like the users, intruders and malware

## Protection of Resources

A computer contains various resources (objects):

- memory pages, memory segments.
- I/O devices (disk, network, printers, monitors).
- dynamic libraries.

They are accessed by subjects:

- users, groups, processes.

The OS ensures that objects are only accessed by authorized subjects, like:

- processes can only have direct access to their own memory segments.
- each file can only be accessed only by a set of users.

### Protection

Separation - prevent arbitrary access to objects (**needs to separate** objects from subjects).

Mediation - control the access to the subject (decides **what kind of access** a subject has to an object).

#### Separation

Common OSs run software in 2 different modes:

- **kernel mode** (can play with any system resource).
- **user mode** (access is controlled by the OS).

These modes are enforced by the CPU by disabling a set of its instructions in user mode that are necessary to access resources (e.g. in/out, sti/cli, hlt). It can either generate an exception or do nothing, depending on the instruction the process executes.

How can software execute operations in objects outside its control?:

- the software must call the kernel, so that the OS runs some code to execute that privileged operation on its behalf.
- the OS can then control accesses from user-mode programs to all objects, including system resources.

Two difficulties:

- kernel runs in kernel mode, not user mode.
- kernel memory space is invisible to the process (jump?)

Solution:

- use system calls – a sort of function, but in the OS
- software interruption (aka exception, trap), triggered by a special instruction (e.g., int in Intel CPUs) that forces the CPU to change to kernel mode

#### Memory Protection

System calls solve separation issues for most resources, but what about memory?

- accesses to memory cannot be performed through system calls because of performance issues
- so, what prevents a process in user mode from changing the memory of another process or the kernel?
- by changing memory, one can modify the loaded code, and therefore alter the behavior of the kernel or other processes.

To enforce this protection, there needs to be cooperation (again) between the hardware + OS.

#### Strategies for separation

**Physical separation** - different proccesses use distinct devices.

**Temporal separation** - processes with different security requirements are executed at different times.

**Logical separation** - processes operate under the illusion that no other processes exist (**memory separation**).

**Cryptographic separation** - processes use crypto to conceal their data and/or computations in a way that they become unintelligible to other processes (e.g. Intel SGX/TEE).

Solution? Segmentation, paging or segmentation + paging.

A program’s memory is split in several parts called segments

- typical segments: code, data, stack, heap, …
- each segment has a name.
- memory is (logically) addressed by (name, offset).
- this addressing allows for segments to be placed in any point of physical memory and to be relocated to other areas.
- they can also be stored in auxiliary memory (disk).

How do we implement this?

- there is a **translation table** with the location of the beginning of each segment, which allows the translation of a logical address to a physical address.
- due to performance reasons, the table is managed cooperatively between the OS and the hardware, through the CPU **Memory Management Unit** (**MMU**).

Summary: memory protection ensures:

- a process cannot access (read/write/execute) memory areas that do not belong to it (other processes and the OS).
- a segment of memory can only be accessed (read/write/exec) accordingly to the mode indicated in the translation table, which is setup by the OS.
