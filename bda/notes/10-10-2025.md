### Query Optimization

#### SARGEABLE query

Search ARGuable Query - optimized query

Objectives:

- avoids using functions or calculations on indexed columns in WHERE clause;
- use direct comparisons; if there is a need of function usage;
- create a computed column;
- use paging and limiting instead of the full dataset;
- only sort on small datasets.

#### Implemented

Extended form of relation algebra.  
Evaluation plans are represented as trees of relational operators along with labels that identify the algorithm to use at each node (for most, no algo is universally superior, some unfluencing factors are the sizes fo the tables, existing indexes and sort orders).  
The implementation of these is carefully optimized for good perf. by the query optimizer.  
The query optimizer is responsible for identifying an efficient execution plan.  
Generates alternative plans and chooses the plan with the least estimated cost.

#### Stages

- Parsing and Transaltion
- Optimization
- Evaluation

#### Key Concepts

Query parsing and analysis:

- first step in query optimization, to parse and analyze the query to understand the structure and requirements.
  
Query rewrite:

- some implement query rewrites to transform given queries to equivalent but more efficient ones.
- can involve rewriting subqueries, restructuring conditions or using indexes.

QUery execution:

- multiple execution plan queries.
- step-by-step guide guide on how db engines should retrieve data.
- estimates the cost.

Cost-based optimization:

- use a cost based approach.
- assigns cost to operations and chooses lowest.
- can be different between machines.

Statisctics and Selectivity:

- accurate statistics about the data distribution in the tables are crucial for the optimizer.
- selected tables to be more optimal.

Indexing:

- can significantly improve performance.
- the optimizer evaluates whether to use existing indexes or create new ones based on the query and the structure of the underlying tables.

Join strategies:

- optimizer decides how to execute joins between tables, involves choosing between nested loop joins, hash joins and merge joins based on the available indexes and size of tables.

Caching and Materialized Views:

- can be used to store expensive queries, reducing the need to execute these queries repeatedly.

Parallel processing:

- can be employed to execute query parts concurrently, speeding up query execution.

#### Measure of query cost

System specifications like RAM and disk.

Response time is very hard to estimate:

- depends on the content of the buffer when the query begins the execution. Not available when the query is optimized and is hard to account for even if it were avaialble.
- depends on how accesses are distributed among disks, which is hard to estimate without detailed knowdledge of data layout on disk.

#### Selection Operations

Linear search - scans each file block and tests all records to see whether they satisfy the selection condition (most simple)

#### Sorting

Several joins can be efficiently computed if sorted.

#### Join Operations

Merge join or sort merge join -

Hash join - partition tuples of both relations. Building hash tables from tuples of one or both and use them to find tuples with the same hash code to be compared for equ. If hashes equal, then tuples equal.

Process of selecting the most efficient query-evaluation plan from among the strategies usually possible for processing a given query.  
Do not expect users to write the optimized queries.  
Selecting detailed strategy for query processing.  
Choosing the algo to use for executing an opereations, specific indices to use, etc.  

### Choice of Evaluation Plans

Nested queries are optimized independently, with the outer tuple considered as providing a selection condition.  
Â·
System R optimizer uses left deep join trees (uses heuristics, one of, but not the most optimal query), with selectivity taking priority. Evaluated bottom up. Maintains statistics about relations, estimates result sizes based on cost estimates.  
