### Transactional Systems

#### Graph-based Protocols

Needs previous knowledge about how each transactions accesses the database.  
Partial ordering of sets of data.  
Partial ordering means that the set D may now be viewed as
a directed, acyclic graph (database graph).

Only lock instruction allowed is lock-X.  
Each transaction can lock a data item at most once.
Deadlock-free, no rollbacks required.

#### Timestamp-based Protocols

Ordering among transactions - timestamp-ordering.  
Before execution, a timestamp is assigned to a transaction.  
Can be:

- system clock.
- logical counter.

To each item Q is associated two timestamps:

- W-timestamp Q, largest timestamp of any transaction that executed write(Q) successfully.
- R-timestamp Q, largest timestamp of any transaction that executed read(Q) successfully.

On read if the transaction is:

- older, than the timestamp, it is rolled back to read the updated one.
- younger than the timestamp, it is set to the max timestamp.

On write if the transaction is:

- older than the read, it is rolled back.
- older than the write, it is rolled back.
- younger than both, it is written, setting to the max timestamp.

#### MVCC

Per item, a sequence of versions is associated to it, with the data field, W-timestamp and R-timestamp.

On read, the value returned is the content of the Qk version with the largest write timestamp.

On write, if the transaction is:

- older than the timestamp of read, it gets rolledback.
- equal to the timestamp of write, it is overwritten.
- younger than the timestamp of read, a new version is created.

Read requests never fail and never wait.
Reading of data requires the updating of the read timestamp, resulting in 2 potential disk accesses, rather than
one.
Conflicts between transactions are resolved to rollbacks, rather than through waits.
